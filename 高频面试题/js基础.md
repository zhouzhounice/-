# 谈谈数据类型

js根据存储方式将数据类型分为两种：

- 基本数据类型 - 它的变量名与值都存储在栈内存中
  - String
  - Number
  - Boolean
  - Undefined
  - Null
  - Symbol
  - Bigint
- 引用数据类型 - 它的变量名存在栈内存中，值存在堆内存中，通过地址值联系起来
  - Objecy
  - Array
  - Function
  - Date
  - RegExp
  - Error
  - Math
  - ...

# 谈谈变量提升

​		我们的js代码并不是一句一句去执行的，而是根据函数划分成一块一块的去执行，在执行前需要做一系列准备工作，也叫执行上下文，而变量提升就是执行上下文中的一步，它是将var声明的变量全都提升到所在作用域的最前面，形成一个变量对象。这就是为什么在var声明一个变量之前去打印这个变量，结果是undefined而不是报错的原因，也是在一个函数声明前就调用它能够正常调用而不报错的原因。它之所以存在可能是因为能够让函数直接能够顺利的相互调用。

​		但是在ES6中又新出了两个声明变量的方式let与const，用这两个声明的变量就不会存在变量提升的问题了。

# 谈谈this

this是一个函数内部的指针，指向的是调用这个函数的对象。

要判断函数的this指向就要看函数的调用方式：

- 如果是全局调用，则this指向window
- 如果是对象调用，则this指向此对象
- 如果是new调用，则this指向构造函数的实例对象
- 还有一些情况下，this隐式丢失，此时this会指向window 
  - 函数别名：将函数赋值给另一个变量，对新变量进行操作
  - 参数传递：将函数作为参数传入另一个函数中
  - 内置函数：setTimeout和setInterval

- 在函数使用apply()、call()、bind()等方法时，也会造成this指向的改变
  - apply与call区别：call可以接收若干个参数，而apply只接受两个参数，第二个参数是需要传入参数组成的数组
  - bind与call区别：bind并没有立即调用函数，而是返回给一个已经改变了this的函数，需要我们手动调用这个函数

- es6新增的箭头函数是没有自己的this的，它的this是外层函数的this

# 谈谈作用域、作用域链

  作用域就是规定代码作用的范围和变量查询范围，它的作用是隔离变量，防止命名冲突。

  es6之前可以根据函数划分，分为全局作用域和局部作用域，es6之后就有了块级作用域，用{}来划分。

 作用域链本质是一个数组，里面存放着一级一级的变量对象。当我们查找一个变量时，会先在自身所处的作用域查找，如果没有，则会向上级作用域查找，这样依次查找下次，直到找到最外层的全局作用域，查找变量时的轨迹被称为作用域链

# 谈谈闭包

闭包的本质是一个意外存活的变量对象。

它产生的条件有：函数嵌套函数，内部函数使用外部函数的变量，调用外部函数。

闭包也分为两种：一种是无效闭包，一种是有效闭包。取决于有没有return内部函数，无效闭包会随着外层函数执行完毕销毁，而有效闭包会一直存活。

闭包的好处：延长内部变量的生命周期、模块化

闭包的坏处：由于本该销毁的变量被闭包保存了下来，会占用一定的内存空间，严重时会导致内存泄漏，进而导致内存溢出，导致宕机。

解决闭包的危害：尽量减少使用闭包或者使用之后记得手动销毁闭包（具体就是将内层函数指向null，利用垃圾回收机制来销毁闭包）。

我们平时用到闭包的地方有：防抖节流，还有项目中删除列表某一行的数据时用到

# 谈谈原型、原型链

- 每个函数都有一个显示原型属性prototype

- 每个实例对象都有一个隐式原型属性`__proto__`

- 实例的`__proto__`与对应函数的prototype都指向原型属性

- 原型对象上有一个constructor属性指向对应的构造函数

- 当我们查找一个属性的时候，是现在自身进行查找，找不到就会向原型对象上查找，如果没有，还会向着原型对象的原型对象上查找，直到返回undefined，查找属性的这个轨迹就被称为原型链
- 由于js中由c语言写的内容有三个Objec、Function、Function.prototype，所以原型链中有四条线是作者自己制定的
  - `Function.__proto__ === Function.prototype`
  - `Object.__proto__ === Function.prototype 由于Function和Object都是函数，需要用到这个类型所具有的公告方法，所以必须有这条线`
  - `Function.prototype.__proto__ === Object.prototype 由于js中函数也是对象，所以有权利使用对象身上的方法`
  - `Object.prototype.__proto__ === null 由于js的继承是由原型链实现的，如果Object原型对象的隐式原型属性指向自身，那么原型链会陷入死循环 `

# 谈谈面向对象

- 面向对象是一种编程模式
- 它有三个特点
  - 封装：让代码变得低耦合高内聚
  - 继承：让子类实例继承父类身上的私有和公有的属性和方法
    - 原型继承
    - call继承
    - 寄生组合继承
    - ES6继承
  - 多态
- 

# 数组去重

# 数组扁平化

# 排序算法

